
\section{Querying Retrospective Provenance} 
\label{sec:queries}

Our approach to revealing the retrospective provenance of script
products in the absence of a provenance recorder is based on a number
of observations. Many scientists use directory structures and
directory and file names to organize data produced by scripts and to
denote their relationships. In particular, when scientists write
scripts they often have a set of retrospective provenance queries in
mind that are of such high priority that they want to be able to
answer them without interpreting the contents of log files. This is
especially important when individual log files are independently
written by different programs invoked by the single script.  The
information required to answer these queries is therefore embedded by
scientists in filenames, directory names, and in the hierarchical
directory structures in which data is organized.  Our response to
these observations is to let script writers describe this information
naturally via URI template expressions. In this way \YW\ allows script
writers to declare how script inputs and outputs are named and
organized based on actual data and metadata values occurring at
runtime.

% Although looking through directories to understand what a script did
% can be more effective than looking through multiple log files,
With \YW\ we aim to make scientists even more productive by
eliminating the need to explore directory structures manually.  \yw\
can implement the scientists' high-priority questions as
\emph{provenance queries} using the declared URI template information
together with dependencies introduced by \YW\ script annotations.

% \YW\ thus can provide value by using the declared URI templates in
% scripts to answer scientists' high-priority queries without requiring
% them to inspect the contents of directories.

We report in this section a number of typical provenance queries that
are expressed against our example script. For each query we begin by
describing how a scientist would determine the answer by inspecting
the names and organization of the files produced by the script. We
then provide a more general approach to answering each query that does
not depend on the exact directory structure and file naming
conventions used in the script (while continuing to assume that
sufficient information is recorded in such a manner that a scientist
could answer the question by hand and in the absence of runtime
provenance recording.)

% For the first queries we also summarize how
% these can be implemented using logic rules and facts produced by the
% \yw\ tools.
%  based on its analysis of the script and files it
% discovers matching the URI templates in the script.

Queries $Q_1$ and $Q_2$ represent script run \emph{reports}, i.e.,
they answer questions that the user may have about the samples used,
experimental conditions employed, and results obtained by the script.
Queries $Q_3$ and $Q_4$, on the other hand, are backward and forward
lineage queries, respectively. $Q_3$ identifies an intermediate data
product that a specific final product was derived from; $Q_4$
determines if there are any intermediate products for which there are
no corresponding final products (this is an example of a
\emph{why-not} provenance query). $Q_5$ can be viewed as a data
lineage query that reveals the \emph{physical} provenance of a sample
(the identity of a cassette that stores a specific sample).

As shown below, these and similar queries are answered by generating a
set of relations corresponding to a script's workflow (as defined by
\YW\ annotations) as well as information about resources and their
metadata attributes (from the files generated by a run of the script
and the corresponding URI template information). The result of this
\emph{provenance reconstruction} process generates the base relations
shown in Table~\ref{tbl:baserels}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table*}[!t]
\caption{Base relations generated by the \YW\ provenance 
  reconstruction process.}
\label{tbl:baserels}
\begin{footnotesize}
\begin{tabular}{|l|l|} \hline
{\em Base Relation} & {\em Description} \\ \hline\hline

{\tt program(}{\em id,name,begin\_annot,end\_annot}{\tt )} & 
Identifier, name, and annotation start and end line of workflow 
program blocks
\\ \hline

{\tt port(}{\em id,type,name,annot\_id}{\tt )} & 
Identifier, type (in, out, param), name, and annotation identifier
of workflow ports
\\ \hline

{\tt port\_alias(}{\em port\_id,alias\_name}{\tt )} &
Alias names given to ports (specified via {\tt @AS} annotations) 
\\ \hline

{\tt has\_in\_port(}{\em program\_id,port\_id}{\tt )} &
Input ports of program blocks 
\\ \hline

{\tt has\_out\_port(}{\em program\_id,port\_id}{\tt )} &
Output ports of program blocks 
\\ \hline

{\tt channel(}{\em id,binding}{\tt )} & 
Assignment of script variables to channels
\\ \hline

{\tt port\_connects\_to\_channel(}{\em port\_id,channel\_id}{\tt
    )} & 
Assignment of ports to channels 
\\ \hline

{\tt uri\_variable(}{\em id,name,port\_id}{\tt )} & 
Identifier, name, and associated port of URI metadata variables 
\\ \hline

{\tt resource(}{\em id,uri}{\tt )} & 
Identifier and expanded URI (file path) of resources created by a run of the script 
\\ \hline

{\tt resource\_channel(}{\em resource\_id,channel\_id}{\tt )} & 
Resources that were input to or output by a channel
during a run of the script
\\ \hline  

\end{tabular}
\end{footnotesize}
\end{table*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\paragraph{($Q_1$) \emph{What samples did the run of the script
  collect images from?}} 
The scientist's solution is to look at the contents of the
\code{run/raw/q55} directory (\figref{fig-data-tree}). The names of
subdirectories are the names of the samples collected on.

\textbf{General solution using \yw}: Assume that `what samples' means
`what values of \code{sample\_id} as seen by
\code{collect\_data\_set}'. Then the solution is to look for all
persisted outputs of \code{collect\_data\_set} that include
\code{sample\_id} in the expanded URI template.
Extract the value of \code{sample\_id} from each and return the set of
unique values. $Q_1$ can be expressed as the Datalog query:
\begin{small}
\begin{verbatim}
samples_used(SampleId) :- 
   resource_info(ResourceId,collect_data_set,
                 raw_image,sample_id,SampleId).
\end{verbatim}
\end{small}
where {\tt resource\_info} is a simple view expressed against the
provenance facts reconstructed by \yw\ to obtain the program, port
name, and metadata information of resources.  For our example, the
above query will yield the answers \code{DRT240} and \code{DRT322}.


\paragraph{($Q_2$): What energies were used during collection of
  images from sample \code{DRT322}?}
The scientist's solution is to look at the contents of the
\code{run/raw/q55/DRT322} directory. The names of subdirectories are
the values of the energies.

\textbf{General solution using \yw}: Assume that `what energies' and
`from sample \code{DRT322}' mean `what values of energy as seen by
\code{collect\_data\_set} when \code{sample\_id} equals \code{DRT322}
as seen by \code{collect\_data\_set}'.  Then the solution is to look
for all persisted outputs of \code{collect\_data\_set} that include
both energy and \code{sample\_id} in the expanded URI template for the
output.  Extract the value of energy from each such path for which
\code{sample\_id} equals \code{DRT322} and return the set of unique
values. $Q_2$ can be expressed as the Datalog query: 
\begin{small}
\begin{verbatim}
energies_used(EnergyValue) :-
   resource_info(ResourceId,collect_data_set,
                 raw_image,sample_id,"DRT322"),
   resource_info(ResourceId,collect_data_set,
                 raw_image,energy,EnergyValue).
\end{verbatim}
\end{small}
For our example, the above query will yield the answers \code{10000}
and \code{11000}.

\paragraph{($Q_3$)
  Where is the raw image corresponding to corrected image
  \code{DRT322\_11000ev\_028.img}?}
The scientist's solution is to look at the image files nested within
the \code{raw} directory.  Find the image file that contains the
\code{"DRT322"}, \code{"11000"}, and \code{"028"} in the file access
path.

\textbf{General solution using \yw}: Assume that `raw image for
corrected image' means `what file output by the port named
\code{raw\_image} with values for URI template variables equal to the
matching URI template expansion variables in the path to the file
\code{DRT322\_11000ev\_028.img} output by the port named
\code{corrected\_image}'.  Then the solution is to extract the URI
template variable names and values from the path to
\code{DRT322\_11000ev\_028.img} output by the port named
\code{corrected\_image}, look at the paths for all files output by the
\code{raw\_image} port, and return the file whose path includes
template variables with names and values matching those for
\code{DRT322\_11000ev\_028.img} (not all variables need be present in
both paths, but where the variable with same name is used the values
must match).  $Q_3$ can be expressed as the Datalog query: 
\begin{small}
\begin{verbatim}
raw_image_used(RawImageFile) :-
   resource(CorrectedImage,"./run/data/
            DRT322/DRT322_11000eV_028.img"),
   channel(RawImageChannel,raw_image),
   resource_channel(RawImage,RawImageChannel),
   depends_on(CorrectedImage,RawImage),
   resource(RawImage,RawImageFile).
\end{verbatim}
\end{small}
This query relies on a {\tt depends\_on} relation that computes the
dependencies between resources based on their metadata values and the
workflow graph. In particular, a resource $r_2$ is presumed to have
depended on a resource $r_1$ if: (i) $r_1$ is upstream of $r_2$ in the
corresponding \YW\ workflow graph (based on input-output ports and
channels defined in the script); (ii) $r_1$ and $r_2$ have at least
one metadata variable in common (based on their corresponding URI
templates); and (iii) the metadata variables in common between $r_1$
and $r_2$ have the same values for $r_1$ and $r_2$ (based on their
expanded URIs). \Figref{fig:depends-on} gives a definition of the {\tt
  depends\_on} relation as a Datalog program.

\begin{figure*}[!t]
  \begin{footnotesize}
  \begin{verbatim}
                   depends_on(R1,R2) :- upstream_resource(R2,R1), R1!=R2, common_metadata_var(R1,R2), 
                                        not common_metadata_values_differ(R1,R2), 
          common_metadata_var(R1,R2) :- uri_resource_var_value(R1,N,_), uri_resource_var_value(R2,N,_).
common_metadata_values_differ(R1,R2) :- resource_channel(R1,C1), resource_channel(R2,C2), 
                                        uri_resource_var_value(R1,N,V1), 
                                        uri_resource_var_value(R2,N,V2), V1!=V2.
       uri_resource_var_value(R,N,V) :- uri_variable(X,N,_), uri_variable_value(R,X,V).
            upstream_resource(R1,R2) :- resource_channel(R1,C1), port_connects_to_channel(P1,C1), 
                                        resource_channel(R2,C2), port_connects_to_channel(P2,C2), 
                                        port_dep_tc(P2,P1).
                     port_dep(P2,P1) :- has_in_port(B,P1), has_out_port(B,P2).
                     port_dep(P2,P1) :- has_in_port(_,P2), has_out_port(_,P1), channel(C,_), 
                                        port_connects_to_channel(P1,C), port_connects_to_channel(P2,C).
                  port_dep_tc(P2,P1) :- port_dep(P2,P1).
                  port_dep_tc(P2,P1) :- port_dep_tc(P2,P), port_dep_tc(P,P1).
  \end{verbatim}
  \end{footnotesize}
  \caption{A Datalog program for calculating resource dependencies ({\tt depends\_on}) in \YW.}
  \label{fig:depends-on}
\end{figure*}

\paragraph{($Q_4$)
  Are there any raw images for which \emph{no} corrected image was written?}
This is somewhat similar to $Q_ 3$, but follows the lineage in the
``forward direction'' and (unlike $Q_4$) asks about the absence of
data.  In this case the path to each file written by the
\code{raw\_image} port is examined, and a corresponding file written
by the \code{corrected\_image} port is sought.  Return raw images for
which no corrected image is found.

\paragraph{($Q_5$) What was the id of the cassette from which sample
  leading to \code{DRT240\_10000ev\_010.img} was taken?} This query
shows how the retrospective data lineage information can be used to
track the physical provenance of samples.  The general solution here
is to search the upstream lineage of data provided to
\code{transform\_images}, looking for URI templates that include
\code{cassette\_id} and \code{sample\_id} as template
variables. Return the value of \code{cassette\_id} that occurs in URI
expansions where \code{sample\_id} matches \code{DRT240}.

\paragraph{Example Code.}
The example Python code, along with the \yw-generated prospective
provenance shown in \figref{fig-wfgraph}, and some of the
\yw-reconstructed retrospective provenance facts and rules are
available from \cite{mcphillips2015example}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "yw-prov-recon"
%%% End:
